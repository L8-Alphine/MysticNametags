package com.mystichorizons.mysticnametags.stats;

import com.google.gson.Gson;
import com.hypixel.hytale.logger.HytaleLogger;

import javax.annotation.Nonnull;
import java.sql.*;
import java.util.UUID;
import java.util.logging.Level;

/**
 * Simple JDBC-based storage for player stats.
 *
 * Table:
 *   mystic_stats_players(
 *       uuid      VARCHAR(36) PRIMARY KEY,
 *       data_json TEXT NOT NULL
 *   )
 *
 * data_json stores the PlayerStatsData JSON generated by GSON.
 */
public final class SqlPlayerStatStore implements PlayerStatStore {

    private static final HytaleLogger LOGGER = HytaleLogger.forEnclosingClass();

    private final String jdbcUrl;
    private final String user;
    private final String password;
    private final Gson gson;

    public SqlPlayerStatStore(@Nonnull String jdbcUrl,
                              @Nonnull String user,
                              @Nonnull String password,
                              @Nonnull Gson gson) {
        this.jdbcUrl = jdbcUrl;
        this.user = user;
        this.password = password;
        this.gson = gson;

        initSchema();
    }

    private Connection getConnection() throws SQLException {
        if (user.isEmpty()) {
            return DriverManager.getConnection(jdbcUrl);
        }
        return DriverManager.getConnection(jdbcUrl, user, password);
    }

    private void initSchema() {
        String sql = """
                CREATE TABLE IF NOT EXISTS mystic_stats_players (
                    uuid      VARCHAR(36) PRIMARY KEY,
                    data_json TEXT NOT NULL
                )
                """;

        try (Connection c = getConnection();
             Statement st = c.createStatement()) {
            st.execute(sql);
        } catch (SQLException e) {
            LOGGER.at(Level.SEVERE).withCause(e)
                    .log("[MysticNameTags] Failed to initialize mystic_stats_players schema.");
        }
    }

    @Override
    public @Nonnull PlayerStatsData load(@Nonnull UUID uuid) {
        String sql = "SELECT data_json FROM mystic_stats_players WHERE uuid = ?";

        try (Connection c = getConnection();
             PreparedStatement ps = c.prepareStatement(sql)) {

            ps.setString(1, uuid.toString());
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    String json = rs.getString(1);
                    if (json != null && !json.isEmpty()) {
                        PlayerStatsData data = gson.fromJson(json, PlayerStatsData.class);
                        return (data != null) ? data : new PlayerStatsData();
                    }
                }
            }
        } catch (SQLException e) {
            LOGGER.at(Level.WARNING).withCause(e)
                    .log("[MysticNameTags] Failed to load stats row for " + uuid);
        }

        return new PlayerStatsData();
    }

    @Override
    public void save(@Nonnull UUID uuid, @Nonnull PlayerStatsData data) {
        String json = gson.toJson(data);

        String sql = """
                INSERT INTO mystic_stats_players (uuid, data_json)
                VALUES (?, ?)
                ON DUPLICATE KEY UPDATE data_json = VALUES(data_json)
                """;

        // SQLite doesn't support ON DUPLICATE KEY; fallback to REPLACE INTO
        boolean sqlite = jdbcUrl.startsWith("jdbc:sqlite:");
        if (sqlite) {
            sql = "REPLACE INTO mystic_stats_players (uuid, data_json) VALUES (?, ?)";
        }

        try (Connection c = getConnection();
             PreparedStatement ps = c.prepareStatement(sql)) {

            ps.setString(1, uuid.toString());
            ps.setString(2, json);
            ps.executeUpdate();
        } catch (SQLException e) {
            LOGGER.at(Level.WARNING).withCause(e)
                    .log("[MysticNameTags] Failed to save stats row for " + uuid);
        }
    }

    @Override
    public void delete(@Nonnull UUID uuid) {
        String sql = "DELETE FROM mystic_stats_players WHERE uuid = ?";

        try (Connection c = getConnection();
             PreparedStatement ps = c.prepareStatement(sql)) {
            ps.setString(1, uuid.toString());
            ps.executeUpdate();
        } catch (SQLException e) {
            LOGGER.at(Level.WARNING).withCause(e)
                    .log("[MysticNameTags] Failed to delete stats row for " + uuid);
        }
    }
}